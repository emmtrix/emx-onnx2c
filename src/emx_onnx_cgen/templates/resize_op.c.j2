static inline void {{ op_name }}({{ dim_args }}{{ params | join(', ') }}) {
    const int64_t input_shape[{{ rank }}] = { {% for dim in input_shape %}{{ dim }}{% if not loop.last %}, {% endif %}{% endfor %} };
    const int64_t output_shape[{{ rank }}] EMX_UNUSED = { {% for dim in output_shape %}{{ dim }}{% if not loop.last %}, {% endif %}{% endfor %} };
    double scales[{{ rank }}] EMX_UNUSED;
{% if roi_input %}
    double roi[{{ rank * 2 }}] EMX_UNUSED;
{% if roi_axes %}
    for (idx_t r = 0; r < {{ rank }}; ++r) {
        roi[r] = 0.0;
        roi[r + {{ rank }}] = 1.0;
    }
{% for axis in axes %}
    roi[{{ axis }}] = (double){{ roi_input }}[{{ roi_axis_map[loop.index0] }}];
    roi[{{ axis + rank }}] = (double){{ roi_input }}[{{ roi_axis_map[loop.index0] + (axes | length) }}];
{% endfor %}
{% else %}
    for (idx_t r = 0; r < {{ rank * 2 }}; ++r) {
        roi[r] = (double){{ roi_input }}[r];
    }
{% endif %}
{% else %}
    const double roi[{{ rank * 2 }}] EMX_UNUSED = {
{% for _ in range(rank) %}        0.0{% if not loop.last %},{% endif %}
{% endfor %}{% if rank > 0 %},{% endif %}
{% for _ in range(rank) %}        1.0{% if not loop.last %},{% endif %}
{% endfor %}
    };
{% endif %}
{% if scales_input %}
{% if scales_axes %}
    for (idx_t r = 0; r < {{ rank }}; ++r) {
        scales[r] = 1.0;
    }
{% for axis in axes %}
    scales[{{ axis }}] = (double){{ scales_input }}[{{ scales_axis_map[loop.index0] }}];
{% endfor %}
{% else %}
{% for axis in range(rank) %}
    scales[{{ axis }}] = (double){{ scales_input }}[{{ axis }}];
{% endfor %}
{% endif %}
{% elif sizes_input %}
{% if keep_aspect_ratio_policy != "stretch" %}
{% if keep_aspect_ratio_policy == "not_larger" %}
    double scale_value = INFINITY;
{% else %}
    double scale_value = 0.0;
{% endif %}
{% for axis in axes %}
    {
        const double size_axis = (double){{ sizes_input }}[{{ sizes_axis_map[loop.index0] }}];
        const double axis_scale = size_axis / (double)input_shape[{{ axis }}];
{% if keep_aspect_ratio_policy == "not_larger" %}
        if (axis_scale < scale_value) {
            scale_value = axis_scale;
        }
{% else %}
        if (axis_scale > scale_value) {
            scale_value = axis_scale;
        }
{% endif %}
    }
{% endfor %}
    for (idx_t r = 0; r < {{ rank }}; ++r) {
        scales[r] = 1.0;
    }
{% for axis in axes %}
    scales[{{ axis }}] = scale_value;
{% endfor %}
{% else %}
    for (idx_t r = 0; r < {{ rank }}; ++r) {
        scales[r] = 1.0;
    }
{% for axis in axes %}
    scales[{{ axis }}] = (double){{ sizes_input }}[{{ sizes_axis_map[loop.index0] }}] / (double)input_shape[{{ axis }}];
{% endfor %}
{% endif %}
{% else %}
{% for axis in range(rank) %}
    scales[{{ axis }}] = {{ scales[axis] }};
{% endfor %}
{% endif %}
{% for dim in output_shape %}
for (idx_t {{ loop_vars[loop.index0] }} = 0; {{ loop_vars[loop.index0] }} < {{ dim }}; ++{{ loop_vars[loop.index0] }}) {
{% endfor %}
int use_extrapolation = 0;
{% for dim in range(rank) %}
double x_orig{{ dim }};
{% if coordinate_transformation_mode == "align_corners" %}
if (output_shape[{{ dim }}] == 1) {
    x_orig{{ dim }} = 0.0;
} else {
    x_orig{{ dim }} = (double){{ loop_vars[dim] }} * (input_shape[{{ dim }}] - 1) / (double)(output_shape[{{ dim }}] - 1);
}
{% elif coordinate_transformation_mode == "asymmetric" %}
x_orig{{ dim }} = (double){{ loop_vars[dim] }} / scales[{{ dim }}];
{% elif coordinate_transformation_mode == "tf_crop_and_resize" %}
{
    const double roi_start = roi[{{ dim }}];
    const double roi_end = roi[{{ dim + rank }}];
    if (output_shape[{{ dim }}] == 1) {
        x_orig{{ dim }} = (roi_end - roi_start) * (input_shape[{{ dim }}] - 1) / 2.0;
    } else {
        x_orig{{ dim }} = (double){{ loop_vars[dim] }} * (roi_end - roi_start) * (input_shape[{{ dim }}] - 1)
            / (double)(output_shape[{{ dim }}] - 1);
    }
    x_orig{{ dim }} += roi_start * (input_shape[{{ dim }}] - 1);
    if (x_orig{{ dim }} < 0.0 || x_orig{{ dim }} > (double)(input_shape[{{ dim }}] - 1)) {
        use_extrapolation = 1;
    }
}
{% elif coordinate_transformation_mode == "pytorch_half_pixel" %}
if (output_shape[{{ dim }}] == 1) {
    x_orig{{ dim }} = -0.5;
} else {
    x_orig{{ dim }} = ((double){{ loop_vars[dim] }} + 0.5) / scales[{{ dim }}] - 0.5;
}
{% elif coordinate_transformation_mode == "half_pixel_symmetric" %}
{
    const double output_width = scales[{{ dim }}] * (double)input_shape[{{ dim }}];
    const double adjustment = (double)output_shape[{{ dim }}] / output_width;
    const double center = (double)input_shape[{{ dim }}] / 2.0;
    const double offset = center * (1.0 - adjustment);
    x_orig{{ dim }} = offset + ((double){{ loop_vars[dim] }} + 0.5) / scales[{{ dim }}] - 0.5;
}
{% else %}
x_orig{{ dim }} = ((double){{ loop_vars[dim] }} + 0.5) / scales[{{ dim }}] - 0.5;
{% endif %}
{% endfor %}
if (use_extrapolation) {
    {{ output }}{% for var in loop_vars %}[{{ var }}]{% endfor %} = ({{ c_type }}){{ extrapolation_value }};
} else {
{% if mode == "nearest" %}
{% for dim in range(rank) %}
    const double x_val{{ dim }} = x_orig{{ dim }};
    const double x_floor{{ dim }} EMX_UNUSED = floor(x_val{{ dim }});
    const double x_ceil{{ dim }} EMX_UNUSED = ceil(x_val{{ dim }});
    int idx{{ dim }};
{% if nearest_mode == "round_prefer_floor" %}
    idx{{ dim }} = (x_val{{ dim }} - x_floor{{ dim }} <= 0.5) ? (int)x_floor{{ dim }} : (int)x_ceil{{ dim }};
{% elif nearest_mode == "round_prefer_ceil" %}
    idx{{ dim }} = (x_val{{ dim }} - x_floor{{ dim }} < 0.5) ? (int)x_floor{{ dim }} : (int)x_ceil{{ dim }};
{% elif nearest_mode == "floor" %}
    idx{{ dim }} = (int)x_floor{{ dim }};
{% else %}
    idx{{ dim }} = (int)x_ceil{{ dim }};
{% endif %}
    if (idx{{ dim }} < 0) {
        idx{{ dim }} = 0;
    } else if (idx{{ dim }} >= input_shape[{{ dim }}]) {
        idx{{ dim }} = (int)input_shape[{{ dim }}] - 1;
    }
{% endfor %}
    {{ output }}{% for var in loop_vars %}[{{ var }}]{% endfor %} = {{ input0 }}{% for dim in range(rank) %}[idx{{ dim }}]{% endfor %};
{% else %}
    double acc = 0.0;
{% for dim in range(rank) %}
    double x_floor{{ dim }} = floor(x_orig{{ dim }});
    double ratio{{ dim }} = x_orig{{ dim }} - x_floor{{ dim }};
    const int is_integer{{ dim }} = ratio{{ dim }} == 0.0;
    if (is_integer{{ dim }}) {
        ratio{{ dim }} = 1.0;
    }
    int count{{ dim }};
{% if antialias %}
    double scale_clamped{{ dim }} = scales[{{ dim }}] < 1.0 ? scales[{{ dim }}] : 1.0;
{% if mode == "linear" %}
    int coeff_start{{ dim }} = (int)floor(-1.0 / scale_clamped{{ dim }}) + 1;
    count{{ dim }} = 2 - 2 * coeff_start{{ dim }};
{% else %}
    int coeff_start{{ dim }} = (int)floor(-2.0 / scale_clamped{{ dim }}) + 1;
    int coeff_end{{ dim }} = 2 - coeff_start{{ dim }};
    count{{ dim }} = coeff_end{{ dim }} - coeff_start{{ dim }};
{% endif %}
{% else %}
{% if mode == "linear" %}
    count{{ dim }} = 2;
{% else %}
    count{{ dim }} = 4;
{% endif %}
{% endif %}
    int start_index{{ dim }} = (int)x_floor{{ dim }} - (count{{ dim }} / 2);
    if (!is_integer{{ dim }}) {
        start_index{{ dim }} += 1;
    }
    int idx{{ dim }}_values[count{{ dim }}];
    double coeff{{ dim }}[count{{ dim }}];
{% if antialias %}
    double coeff_sum{{ dim }} = 0.0;
    for (int c = 0; c < count{{ dim }}; ++c) {
        idx{{ dim }}_values[c] = start_index{{ dim }} + c;
{% if mode == "linear" %}
        double arg = (coeff_start{{ dim }} + c - ratio{{ dim }}) * scale_clamped{{ dim }};
        double coeff = 1.0 - fabs(arg);
        if (coeff < 0.0) {
            coeff = 0.0;
        }
{% else %}
        double x = scale_clamped{{ dim }} * (coeff_start{{ dim }} + c - ratio{{ dim }});
        double ax = fabs(x);
        double coeff;
        if (ax <= 1.0) {
            coeff = ({{ cubic_coeff_a }} + 2.0) * ax * ax * ax - ({{ cubic_coeff_a }} + 3.0) * ax * ax + 1.0;
        } else if (ax < 2.0) {
            coeff = {{ cubic_coeff_a }} * ax * ax * ax - 5.0 * {{ cubic_coeff_a }} * ax * ax + 8.0 * {{ cubic_coeff_a }} * ax - 4.0 * {{ cubic_coeff_a }};
        } else {
            coeff = 0.0;
        }
{% endif %}
        coeff{{ dim }}[c] = coeff;
        coeff_sum{{ dim }} += coeff;
    }
    if (coeff_sum{{ dim }} > 0.0) {
        for (int c = 0; c < count{{ dim }}; ++c) {
            coeff{{ dim }}[c] /= coeff_sum{{ dim }};
        }
    }
{% else %}
    for (int c = 0; c < count{{ dim }}; ++c) {
        idx{{ dim }}_values[c] = start_index{{ dim }} + c;
    }
{% if mode == "linear" %}
    coeff{{ dim }}[0] = 1.0 - ratio{{ dim }};
    coeff{{ dim }}[1] = ratio{{ dim }};
{% else %}
    {
        const double t = 1.0 - ratio{{ dim }};
        coeff{{ dim }}[0] = (({{ cubic_coeff_a }} * (ratio{{ dim }} + 1.0) - 5.0 * {{ cubic_coeff_a }}) * (ratio{{ dim }} + 1.0) + 8.0 * {{ cubic_coeff_a }}) * (ratio{{ dim }} + 1.0) - 4.0 * {{ cubic_coeff_a }};
        coeff{{ dim }}[1] = (({{ cubic_coeff_a }} + 2.0) * ratio{{ dim }} - ({{ cubic_coeff_a }} + 3.0)) * ratio{{ dim }} * ratio{{ dim }} + 1.0;
        coeff{{ dim }}[2] = (({{ cubic_coeff_a }} + 2.0) * t - ({{ cubic_coeff_a }} + 3.0)) * t * t + 1.0;
        coeff{{ dim }}[3] = (({{ cubic_coeff_a }} * (t + 1.0) - 5.0 * {{ cubic_coeff_a }}) * (t + 1.0) + 8.0 * {{ cubic_coeff_a }}) * (t + 1.0) - 4.0 * {{ cubic_coeff_a }};
    }
{% endif %}
{% endif %}
{% if exclude_outside %}
    {
        double coeff_sum{{ dim }} = 0.0;
        for (int c = 0; c < count{{ dim }}; ++c) {
            if (idx{{ dim }}_values[c] < 0 || idx{{ dim }}_values[c] >= input_shape[{{ dim }}]) {
                coeff{{ dim }}[c] = 0.0;
            }
            coeff_sum{{ dim }} += coeff{{ dim }}[c];
        }
        if (coeff_sum{{ dim }} > 0.0) {
            for (int c = 0; c < count{{ dim }}; ++c) {
                coeff{{ dim }}[c] /= coeff_sum{{ dim }};
            }
        }
    }
{% endif %}
{% endfor %}
{% for dim in range(rank) %}
    for (int n{{ dim }} = 0; n{{ dim }} < count{{ dim }}; ++n{{ dim }}) {
{% endfor %}
        double weight = 1.0;
{% for dim in range(rank) %}
        weight *= coeff{{ dim }}[n{{ dim }}];
{% endfor %}
{% for dim in range(rank) %}
        int idx{{ dim }} = idx{{ dim }}_values[n{{ dim }}];
        if (idx{{ dim }} < 0) {
            idx{{ dim }} = 0;
        } else if (idx{{ dim }} >= input_shape[{{ dim }}]) {
            idx{{ dim }} = (int)input_shape[{{ dim }}] - 1;
        }
{% endfor %}
        acc += weight * (double){{ input0 }}{% for dim in range(rank) %}[idx{{ dim }}]{% endfor %};
{% for dim in range(rank) %}
    }
{% endfor %}
    {{ output }}{% for var in loop_vars %}[{{ var }}]{% endfor %} = ({{ c_type }})acc;
{% endif %}
}
{% for _ in output_shape %}
}
{% endfor %}
}
