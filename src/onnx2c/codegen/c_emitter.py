from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from jinja2 import Environment, FileSystemLoader, select_autoescape

from ..errors import CodegenError


@dataclass(frozen=True)
class BinaryOp:
    input0: str
    input1: str
    output: str
    operator: str


@dataclass(frozen=True)
class UnaryOp:
    input0: str
    output: str
    operator: str


@dataclass(frozen=True)
class LoweredModel:
    name: str
    input_names: tuple[str, ...]
    output_name: str
    element_count: int
    ops: tuple[BinaryOp | UnaryOp, ...]


class CEmitter:
    def __init__(self, template_dir: Path) -> None:
        self._env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(enabled_extensions=()),
            trim_blocks=True,
            lstrip_blocks=True,
        )

    def emit_model(self, model: LoweredModel) -> str:
        try:
            binary_template = self._env.get_template("binary_op.c.j2")
            unary_template = self._env.get_template("unary_op.c.j2")
        except Exception as exc:  # pragma: no cover - template load failure
            raise CodegenError("Failed to load C template") from exc
        temp_map = self._temp_buffers(model)
        resolved_ops = [
            self._resolve_op(op, temp_map) for op in model.ops
        ]
        operator_fns = "\n\n".join(
            self._render_op(
                model,
                op,
                index,
                binary_template=binary_template,
                unary_template=unary_template,
            )
            for index, op in enumerate(resolved_ops)
        )
        wrapper_fn = self._emit_model_wrapper(
            model, resolved_ops, tuple(temp_map.values())
        )
        includes = ["#include <stddef.h>"]
        if any(
            isinstance(op, UnaryOp) and op.operator == "tanhf"
            for op in resolved_ops
        ):
            includes.append("#include <math.h>")
        rendered = "\n".join(
            (
                "// Generated by emx-onnx2c (MVP)",
                *includes,
                "",
                operator_fns.rstrip(),
                "",
                wrapper_fn,
                "",
            )
        )
        if not rendered.endswith("\n"):
            rendered += "\n"
        return rendered

    def _emit_model_wrapper(
        self,
        model: LoweredModel,
        resolved_ops: list[BinaryOp | UnaryOp],
        temp_buffers: tuple[str, ...],
    ) -> str:
        signature = ", ".join(
            f"const float* {name}" for name in model.input_names
        )
        lines = [f"void {model.name}({signature}, float* {model.output_name}) {{"]
        for temp in temp_buffers:
            lines.append(f"    float {temp}[{model.element_count}];")
        for index, op in enumerate(resolved_ops):
            if isinstance(op, BinaryOp):
                call = f"{op.input0}, {op.input1}, {op.output}"
            else:
                call = f"{op.input0}, {op.output}"
            lines.append(f"    {model.name}_op{index}({call});")
        lines.append("}")
        return "\n".join(lines)

    def _temp_buffers(self, model: LoweredModel) -> dict[str, str]:
        intermediates = [
            self._op_output(op)
            for op in model.ops
            if self._op_output(op) != model.output_name
        ]
        if not intermediates:
            return {}
        if len(intermediates) == 1:
            return {intermediates[0]: "tmp"}
        return {
            name: f"tmp{index}"
            for index, name in enumerate(intermediates)
        }

    @staticmethod
    def _resolve_op(
        op: BinaryOp | UnaryOp, temp_map: dict[str, str]
    ) -> BinaryOp | UnaryOp:
        if isinstance(op, BinaryOp):
            return BinaryOp(
                input0=temp_map.get(op.input0, op.input0),
                input1=temp_map.get(op.input1, op.input1),
                output=temp_map.get(op.output, op.output),
                operator=op.operator,
            )
        return UnaryOp(
            input0=temp_map.get(op.input0, op.input0),
            output=temp_map.get(op.output, op.output),
            operator=op.operator,
        )

    @staticmethod
    def _render_op(
        model: LoweredModel,
        op: BinaryOp | UnaryOp,
        index: int,
        *,
        binary_template,
        unary_template,
    ) -> str:
        common = {
            "model_name": model.name,
            "op_name": f"{model.name}_op{index}",
            "element_count": model.element_count,
            "operator": op.operator,
        }
        if isinstance(op, BinaryOp):
            return binary_template.render(
                **common,
                input0=op.input0,
                input1=op.input1,
                output=op.output,
            ).rstrip()
        return unary_template.render(
            **common,
            input0=op.input0,
            output=op.output,
        ).rstrip()

    @staticmethod
    def _op_output(op: BinaryOp | UnaryOp) -> str:
        return op.output
