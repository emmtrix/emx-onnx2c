/*
 * Generated by emmtrix ONNX-to-C Code Generator (emx-onnx-cgen)
 *
 * Command line: n/a
 * Model checksum (sha256): 353e88e68b0497f06ef44dbdb6b9052fecb358f3370f1af0bfef06167d405dbc
 * Model name: model
 * Graph name: concat_graph
 * Inputs: 2 Outputs: 1 Nodes: 1 Initializers: 0
 * IR version: 7
 * Model version: n/a
 * Domain: n/a
 * Producer: onnx2c (version: n/a)
 * Opset imports: ai.onnx=13
 * Description:
 *   n/a
 * Graph description:
 *   n/a
 * Metadata:
 *   n/a
 */

#include <stdint.h>
#include <string.h>

#ifndef idx_t
#define idx_t int32_t
#endif

/*
 * Node 0:
 * OpType: Concat
 * Name: n/a
 * Inputs: in0, in1
 * Outputs: out
 * Attrs:
 *   axis: 2
 */
static inline void node0_concat(const float input_0[restrict 1][2][3], const float input_1[restrict 1][2][1], float output[restrict 1][2][4]) {
    const void *inputs[] = { input_0, input_1 };
    const idx_t axis_sizes[] = { 3, 1 };
    idx_t concat_axis = 0;
    for (idx_t idx = 0; idx < 2; ++idx) {
        concat_axis += axis_sizes[idx];
    }
    if (concat_axis == 0) {
        return;
    }
    for (idx_t outer_idx = 0; outer_idx < 2; ++outer_idx) {
        idx_t output_offset = outer_idx * concat_axis * 1;
        idx_t axis_offset = 0;
        for (idx_t input_idx = 0; input_idx < 2; ++input_idx) {
            idx_t axis = axis_sizes[input_idx];
            idx_t copy_elems = axis * 1;
            const unsigned char *input_bytes =
            (const unsigned char *)inputs[input_idx];
            idx_t input_offset = outer_idx * copy_elems;
            memcpy(
            ((unsigned char *)output) + (output_offset + axis_offset) * sizeof(float),
            input_bytes + input_offset * sizeof(float),
            copy_elems * sizeof(float)
            );
            axis_offset += copy_elems;
        }
    }
}

void model(const float in0[restrict 1][2][3], const float in1[restrict 1][2][1], float out[restrict 1][2][4]) {
    node0_concat(in0, in1, out);
}
