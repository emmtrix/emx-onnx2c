/*
 * Generated by emmtrix ONNX to C Compiler (emx-onnx2c)
 *
 * Command line: n/a
 * Model checksum (sha256): 1ed3cddc10f647867b6c5d7ea7603c4aee39fcd3cee12d3bd6cc0dd6ffc5db25
 * Model name: model
 * Graph name: resize_graph
 * Inputs: 1 Outputs: 1 Nodes: 1 Initializers: 1
 * IR version: 7
 * Model version: n/a
 * Domain: n/a
 * Producer: onnx2c (version: n/a)
 * Opset imports: ai.onnx=13
 * Description:
 *   n/a
 * Graph description:
 *   n/a
 * Metadata:
 *   n/a
 */

#include <stddef.h>
#include <stdint.h>
#include <math.h>

static const int64_t sizes[4] = {
    1LL, 1LL, 4LL, 4LL
};

/*
 * Node 0:
 * OpType: Resize
 * Inputs: in0, , , sizes
 * Outputs: out
 * Attrs:
 *   coordinate_transformation_mode: asymmetric
 *   mode: nearest
 *   nearest_mode: floor
 */
static inline void model_op0(const float in0[restrict 1][1][2][2], const int64_t sizes[restrict 4], float out[restrict 1][1][4][4]) {
    const int64_t input_shape[4] = { 1, 1, 2, 2 };
    const int64_t output_shape[4] = { 1, 1, 4, 4 };
    double scales[4];
    const double roi[8] = {
        0.0,        0.0,        0.0,        0.0,        1.0,        1.0,        1.0,        1.0    };
    for (size_t r = 0; r < 4; ++r) {
        scales[r] = 1.0;
    }
    scales[0] = (double)sizes[0] / (double)input_shape[0];
    scales[1] = (double)sizes[1] / (double)input_shape[1];
    scales[2] = (double)sizes[2] / (double)input_shape[2];
    scales[3] = (double)sizes[3] / (double)input_shape[3];
    for (size_t i0 = 0; i0 < 1; ++i0) {
        for (size_t i1 = 0; i1 < 1; ++i1) {
            for (size_t i2 = 0; i2 < 4; ++i2) {
                for (size_t i3 = 0; i3 < 4; ++i3) {
                    int use_extrapolation = 0;
                    double x_orig0;
                    x_orig0 = (double)i0 / scales[0];
                    double x_orig1;
                    x_orig1 = (double)i1 / scales[1];
                    double x_orig2;
                    x_orig2 = (double)i2 / scales[2];
                    double x_orig3;
                    x_orig3 = (double)i3 / scales[3];
                    if (use_extrapolation) {
                        out[i0][i1][i2][i3] = (float)0.0;
                    } else {
                        const double x_val0 = x_orig0;
                        const double x_floor0 = floor(x_val0);
                        const double x_ceil0 = ceil(x_val0);
                        int idx0;
                        idx0 = (int)x_floor0;
                        if (idx0 < 0) {
                            idx0 = 0;
                        } else if (idx0 >= input_shape[0]) {
                            idx0 = (int)input_shape[0] - 1;
                        }
                        const double x_val1 = x_orig1;
                        const double x_floor1 = floor(x_val1);
                        const double x_ceil1 = ceil(x_val1);
                        int idx1;
                        idx1 = (int)x_floor1;
                        if (idx1 < 0) {
                            idx1 = 0;
                        } else if (idx1 >= input_shape[1]) {
                            idx1 = (int)input_shape[1] - 1;
                        }
                        const double x_val2 = x_orig2;
                        const double x_floor2 = floor(x_val2);
                        const double x_ceil2 = ceil(x_val2);
                        int idx2;
                        idx2 = (int)x_floor2;
                        if (idx2 < 0) {
                            idx2 = 0;
                        } else if (idx2 >= input_shape[2]) {
                            idx2 = (int)input_shape[2] - 1;
                        }
                        const double x_val3 = x_orig3;
                        const double x_floor3 = floor(x_val3);
                        const double x_ceil3 = ceil(x_val3);
                        int idx3;
                        idx3 = (int)x_floor3;
                        if (idx3 < 0) {
                            idx3 = 0;
                        } else if (idx3 >= input_shape[3]) {
                            idx3 = (int)input_shape[3] - 1;
                        }
                        out[i0][i1][i2][i3] = in0[idx0][idx1][idx2][idx3];
                    }
                }
            }
        }
    }
}

void model(const float in0[restrict 1][1][2][2], float out[restrict 1][1][4][4]) {
    model_op0(in0, sizes, out);
}
