/*
 * Generated by emmtrix ONNX-to-C Code Generator (emx-onnx-cgen)
 *
 * Command line: n/a
 * Model checksum (sha256): 1ed3cddc10f647867b6c5d7ea7603c4aee39fcd3cee12d3bd6cc0dd6ffc5db25
 * Model name: model
 * Graph name: resize_graph
 * Inputs: 1 Outputs: 1 Nodes: 1 Initializers: 1
 * IR version: 7
 * Model version: n/a
 * Domain: n/a
 * Producer: onnx2c (version: n/a)
 * Opset imports: ai.onnx=13
 * Description:
 *   n/a
 * Graph description:
 *   n/a
 * Metadata:
 *   n/a
 */

#include <stdint.h>
#include <math.h>

#ifndef idx_t
#define idx_t int32_t
#endif
#ifndef EMX_UNUSED
#if defined(__GNUC__) || defined(__clang__)
#define EMX_UNUSED __attribute__((unused))
#else
#define EMX_UNUSED
#endif
#endif

/*
 * Weight 1:
 * Name: weight1_sizes
 * Shape: (4,)
 * Elements: 4
 * Dtype: int64
 */
extern const int64_t weight1_sizes[4];

/*
 * Weight 1:
 * Name: weight1_sizes
 * Shape: (4,)
 * Elements: 4
 * Dtype: int64
 */
const EMX_UNUSED int64_t weight1_sizes[4] = {
    1LL, 1LL, 4LL, 4LL
};

/*
 * Node 0:
 * OpType: Resize
 * Name: n/a
 * Inputs: in0, , , sizes
 * Outputs: out
 * Attrs:
 *   coordinate_transformation_mode: asymmetric
 *   mode: nearest
 *   nearest_mode: floor
 */
static inline void node0_resize(const float input0[1][1][2][2], const int64_t sizes_input[4], float output[1][1][4][4]) {
    const int64_t input_shape[4] = { 1, 1, 2, 2 };
    const int64_t output_shape[4] EMX_UNUSED = { 1, 1, 4, 4 };
    double scales[4] EMX_UNUSED;
    const double roi[8] EMX_UNUSED = {
        0.0,        0.0,        0.0,        0.0,        1.0,        1.0,        1.0,        1.0    };
    for (idx_t r = 0; r < 4; ++r) {
        scales[r] = 1.0;
    }
    scales[0] = (double)sizes_input[0] / (double)input_shape[0];
    scales[1] = (double)sizes_input[1] / (double)input_shape[1];
    scales[2] = (double)sizes_input[2] / (double)input_shape[2];
    scales[3] = (double)sizes_input[3] / (double)input_shape[3];
    for (idx_t i0 = 0; i0 < 1; ++i0) {
        for (idx_t i1 = 0; i1 < 1; ++i1) {
            for (idx_t i2 = 0; i2 < 4; ++i2) {
                for (idx_t i3 = 0; i3 < 4; ++i3) {
                    int use_extrapolation = 0;
                    double x_orig0;
                    x_orig0 = (double)i0 / scales[0];
                    double x_orig1;
                    x_orig1 = (double)i1 / scales[1];
                    double x_orig2;
                    x_orig2 = (double)i2 / scales[2];
                    double x_orig3;
                    x_orig3 = (double)i3 / scales[3];
                    if (use_extrapolation) {
                        output[i0][i1][i2][i3] = (float)0.0;
                    } else {
                        const double x_val0 = x_orig0;
                        const double x_floor0 EMX_UNUSED = floor(x_val0);
                        const double x_ceil0 EMX_UNUSED = ceil(x_val0);
                        int idx0;
                        idx0 = (int)x_floor0;
                        if (idx0 < 0) {
                            idx0 = 0;
                        } else if (idx0 >= input_shape[0]) {
                            idx0 = (int)input_shape[0] - 1;
                        }
                        const double x_val1 = x_orig1;
                        const double x_floor1 EMX_UNUSED = floor(x_val1);
                        const double x_ceil1 EMX_UNUSED = ceil(x_val1);
                        int idx1;
                        idx1 = (int)x_floor1;
                        if (idx1 < 0) {
                            idx1 = 0;
                        } else if (idx1 >= input_shape[1]) {
                            idx1 = (int)input_shape[1] - 1;
                        }
                        const double x_val2 = x_orig2;
                        const double x_floor2 EMX_UNUSED = floor(x_val2);
                        const double x_ceil2 EMX_UNUSED = ceil(x_val2);
                        int idx2;
                        idx2 = (int)x_floor2;
                        if (idx2 < 0) {
                            idx2 = 0;
                        } else if (idx2 >= input_shape[2]) {
                            idx2 = (int)input_shape[2] - 1;
                        }
                        const double x_val3 = x_orig3;
                        const double x_floor3 EMX_UNUSED = floor(x_val3);
                        const double x_ceil3 EMX_UNUSED = ceil(x_val3);
                        int idx3;
                        idx3 = (int)x_floor3;
                        if (idx3 < 0) {
                            idx3 = 0;
                        } else if (idx3 >= input_shape[3]) {
                            idx3 = (int)input_shape[3] - 1;
                        }
                        output[i0][i1][i2][i3] = input0[idx0][idx1][idx2][idx3];
                    }
                }
            }
        }
    }
}

_Bool model_load(const char *path) {
    (void)path;
    return 1;
}

void model(const float in0[restrict 1][1][2][2], float out[restrict 1][1][4][4]) {
    node0_resize(in0, weight1_sizes, out);
}
