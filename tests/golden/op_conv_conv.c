/*
 * Generated by emmtrix ONNX-to-C Code Generator (emx-onnx-cgen)
 *
 * Command line: n/a
 * Model checksum (sha256): c3e47b6b0afa822e9997d7043d38f74e566c50f2cc0af41969b5739f4f73a96c
 * Model name: model
 * Graph name: conv_graph
 * Inputs: 1 Outputs: 1 Nodes: 1 Initializers: 2
 * IR version: 7
 * Model version: n/a
 * Domain: n/a
 * Producer: onnx2c (version: n/a)
 * Opset imports: ai.onnx=13
 * Description:
 *   n/a
 * Graph description:
 *   n/a
 * Metadata:
 *   n/a
 */

#include <stdint.h>

#ifndef idx_t
#define idx_t int32_t
#endif

/*
 * Weight 1:
 * Name: weight1_weight
 * Shape: (1, 1, 3, 3)
 * Elements: 9
 * Dtype: float
 */
static const float weight1_weight[1][1][3][3] = {
    {
        {
            {
                0x0.0p+0f, 0x1.000000p+0f, 0x1.000000p+1f
            },
            {
                0x1.800000p+1f, 0x1.000000p+2f, 0x1.400000p+2f
            },
            {
                0x1.800000p+2f, 0x1.c00000p+2f, 0x1.000000p+3f
            }
        }
    }
};

/*
 * Weight 2:
 * Name: weight2_bias
 * Shape: (1,)
 * Elements: 1
 * Dtype: float
 */
static const float weight2_bias[1] = {
    0x1.000000p-2f
};

/*
 * Node 0:
 * OpType: Conv
 * Name: n/a
 * Inputs: in0, weight, bias
 * Outputs: out
 * Attrs:
 *   pads: [1, 1, 1, 1]
 *   strides: [1, 1]
 */
static inline void node0_conv(const float input0[restrict 1][1][4][4], const float weights[restrict 1][1][3][3], const float bias[restrict 1], float output[restrict 1][1][4][4]) {
    for (idx_t n = 0; n < 1; ++n) {
        for (idx_t g = 0; g < 1; ++g) {
            for (idx_t oc = 0; oc < 1; ++oc) {
                const idx_t oc_global = g * 1 + oc;
                for (idx_t od0 = 0; od0 < 4; ++od0) {
                    for (idx_t od1 = 0; od1 < 4; ++od1) {
                        float acc = bias[oc_global];
                        for (idx_t ic = 0; ic < 1; ++ic) {
                            const idx_t ic_global = g * 1 + ic;
                            for (idx_t kd0 = 0; kd0 < 3; ++kd0) {
                                for (idx_t kd1 = 0; kd1 < 3; ++kd1) {
                                    const idx_t id0 = od0 * 1 + kd0 * 1 - 1;
                                    const idx_t id1 = od1 * 1 + kd1 * 1 - 1;
                                    if (id0 < 0 || id0 >= 4 || id1 < 0 || id1 >= 4) {
                                        continue;
                                    }
                                    acc += input0[n][ic_global][id0][id1] * weights[oc_global][ic][kd0][kd1];
                                }
                            }
                        }
                        output[n][oc_global][od0][od1] = acc;
                    }
                }
            }
        }
    }
}

void model(const float in0[restrict 1][1][4][4], float out[restrict 1][1][4][4]) {
    node0_conv(in0, weight1_weight, weight2_bias, out);
}
