/*
 * Generated by emmtrix ONNX-to-C Code Generator (emx-onnx-cgen)
 *
 * Command line: n/a
 * Model checksum (sha256): 64f5e44cd32bc296593a2e01f8bf1e59fc218fb53d9f99466360beb164e3e89a
 * Model name: model
 * Graph name: split_graph
 * Inputs: 1 Outputs: 3 Nodes: 1 Initializers: 1
 * IR version: 7
 * Model version: n/a
 * Domain: n/a
 * Producer: onnx2c (version: n/a)
 * Opset imports: ai.onnx=18
 * Description:
 *   n/a
 * Graph description:
 *   n/a
 * Metadata:
 *   n/a
 */

#include <stddef.h>
#include <stdint.h>
#include <string.h>

/*
 * Weight 1:
 * Name: weight1_split
 * Shape: (3,)
 * Elements: 3
 * Dtype: int64
 */
static const int64_t weight1_split[3] = {
    2LL, 2LL, 2LL
};

/*
 * Node 0:
 * OpType: Split
 * Name: n/a
 * Inputs: input, split
 * Outputs: output_0, output_1, output_2
 * Attrs:
 *   axis: 1
 */
static inline void node0_split(const float input0[restrict 2][6], float output_0[restrict 2][2], float output_1[restrict 2][2], float output_2[restrict 2][2]) {
    const float *input_data = (const float *)input0;
    float *output_ptrs[] = { (float *)output_0, (float *)output_1, (float *)output_2 };
    const size_t axis_sizes[] = { 2, 2, 2 };
    for (size_t outer_idx = 0; outer_idx < 2; ++outer_idx) {
        size_t input_base = outer_idx * 6 * 1;
        size_t axis_offset = 0;
        for (size_t output_idx = 0; output_idx < 3; ++output_idx) {
            size_t copy_elems = axis_sizes[output_idx] * 1;
            memcpy(
            output_ptrs[output_idx] + outer_idx * copy_elems,
            input_data + input_base + axis_offset,
            copy_elems * sizeof(float)
            );
            axis_offset += copy_elems;
        }
    }
}

void model(const float input[restrict 2][6], float output_0[restrict 2][2], float output_1[restrict 2][2], float output_2[restrict 2][2]) {
    node0_split(input, output_0, output_1, output_2);
}
